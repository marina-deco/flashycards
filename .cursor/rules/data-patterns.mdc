---
alwaysApply: true
---

# Data Handling Patterns

This project follows specific patterns for data fetching and mutations.

## Core Principles

1. **Data Fetching**: All data reads happen in Server Components
2. **Data Mutations**: All data writes happen via Server Actions
3. **Database Queries**: All database operations are centralized in `db/queries/` helper functions
4. **Never fetch data in Client Components**

## Database Query Organization

**CRITICAL**: All database operations MUST be defined in reusable helper functions in the `db/queries/` directory.

### File Structure

```
src/
  db/
    queries/
      deck-queries.ts    # All deck-related database queries
      card-queries.ts    # All card-related database queries
```

### Query Helper Pattern

```typescript
// src/db/queries/deck-queries.ts
import { db } from "@/db"
import { decks } from "@/db/schema"
import { eq, and } from "drizzle-orm"

export async function getUserDecks(userId: string) {
  return await db.select().from(decks).where(eq(decks.userId, userId))
}

export async function getDeckById(deckId: number, userId: string) {
  const [deck] = await db
    .select()
    .from(decks)
    .where(and(eq(decks.id, deckId), eq(decks.userId, userId)))
  
  return deck
}

export async function createDeck(data: { userId: string; name: string; description?: string }) {
  const [newDeck] = await db.insert(decks).values(data).returning()
  return newDeck
}

export async function updateDeck(deckId: number, userId: string, data: { name?: string; description?: string }) {
  const [updated] = await db
    .update(decks)
    .set(data)
    .where(and(eq(decks.id, deckId), eq(decks.userId, userId)))
    .returning()
  
  return updated
}

export async function deleteDeck(deckId: number, userId: string) {
  await db.delete(decks).where(and(eq(decks.id, deckId), eq(decks.userId, userId)))
}
```

## Server Component Pattern (Data Fetching)

```tsx
// src/app/dashboard/page.tsx
import { auth } from "@clerk/nextjs/server"
import { getUserDecks } from "@/db/queries/deck-queries"

export default async function DashboardPage() {
  const { userId } = await auth()
  
  if (!userId) {
    return <div>Please sign in</div>
  }
  
  // ✅ Fetch data using query helper
  const decks = await getUserDecks(userId)
  
  return (
    <div>
      {decks.map(deck => (
        <div key={deck.id}>{deck.name}</div>
      ))}
    </div>
  )
}
```

## Server Action Pattern (Data Mutations)

```tsx
// src/actions/deck-actions.ts
"use server"

import { auth } from "@clerk/nextjs/server"
import { revalidatePath } from "next/cache"
import { z } from "zod"
import { createDeck, updateDeck, deleteDeck } from "@/db/queries/deck-queries"

const createDeckSchema = z.object({
  name: z.string().min(1, "Name is required"),
  description: z.string().optional(),
})

type CreateDeckInput = z.infer<typeof createDeckSchema>

export async function createDeckAction(input: CreateDeckInput) {
  // 1. Validate input
  const validatedData = createDeckSchema.parse(input)
  
  // 2. Check authentication
  const { userId } = await auth()
  if (!userId) {
    throw new Error("Unauthorized")
  }
  
  // 3. Call query helper to perform database operation
  const newDeck = await createDeck({
    userId,
    ...validatedData,
  })
  
  // 4. Revalidate cache
  revalidatePath("/dashboard")
  
  return newDeck
}
```

## Client Component Pattern (Trigger Mutations)

```tsx
"use client"

import { useState } from "react"
import { createDeckAction } from "@/actions/deck-actions"
import { Button } from "@/components/ui/button"
import { Input } from "@/components/ui/input"

export function CreateDeckForm() {
  const [name, setName] = useState("")
  
  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault()
    
    try {
      await createDeckAction({ name })
      
      // Handle success
    } catch (error) {
      // Handle validation or other errors
      console.error(error)
    }
  }
  
  return (
    <form onSubmit={handleSubmit}>
      <Input 
        value={name} 
        onChange={(e) => setName(e.target.value)} 
      />
      <Button type="submit">Create</Button>
    </form>
  )
}
```

## File Organization

```
src/
  db/
    queries/
      deck-queries.ts    # All deck-related database queries
      card-queries.ts    # All card-related database queries
  actions/
    deck-actions.ts      # All deck-related mutations (calls deck-queries)
    card-actions.ts      # All card-related mutations (calls card-queries)
  app/
    dashboard/
      page.tsx           # Server Component (calls deck-queries for reads)
```

## Required Checklist for Database Queries

- [ ] All database operations are in `db/queries/` directory
- [ ] Query functions are properly typed
- [ ] Query functions include `userId` filtering for user-owned data
- [ ] Query functions are exported for reuse
- [ ] Query functions handle ownership verification

## Required Checklist for Server Actions

- [ ] File has `"use server"` directive at the top
- [ ] Zod schema is defined for input validation
- [ ] TypeScript type is inferred from Zod schema using `z.infer<>`
- [ ] Function parameter uses the TypeScript type (NOT `FormData`)
- [ ] Input is validated with `schema.parse()` or `schema.safeParse()`
- [ ] User authentication is checked with `auth()`
- [ ] **Server action calls query helpers from `db/queries/`** (NEVER direct DB access)
- [ ] Path revalidation is called after mutations

## What NOT to Do

❌ Writing database queries directly in Server Actions
❌ Writing database queries directly in Server Components
❌ Using `FormData` as the parameter type in Server Actions
❌ Skipping Zod validation
❌ Fetching data in Client Components
❌ Using API routes for mutations (use Server Actions instead)
❌ Mutating data directly in Server Components
❌ Accepting unvalidated input from the client
❌ Duplicating database query logic across files

## What TO Do

✅ Define all database queries in `db/queries/` helper functions
✅ Call query helpers from Server Actions for mutations
✅ Call query helpers from Server Components for data fetching
✅ Reuse query helpers across the application
✅ Keep query helpers focused and single-purpose
